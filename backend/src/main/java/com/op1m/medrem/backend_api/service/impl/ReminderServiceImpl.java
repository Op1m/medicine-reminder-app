package com.op1m.medrem.backend_api.service.impl;

import com.op1m.medrem.backend_api.entity.Reminder;
import com.op1m.medrem.backend_api.entity.User;
import com.op1m.medrem.backend_api.entity.Medicine;
import com.op1m.medrem.backend_api.repository.MedicineHistoryRepository;
import com.op1m.medrem.backend_api.repository.ReminderRepository;
import com.op1m.medrem.backend_api.service.ReminderService;
import com.op1m.medrem.backend_api.service.UserService;
import com.op1m.medrem.backend_api.service.MedicineService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.cache.annotation.CacheEvict;
import org.springframework.cache.annotation.Cacheable;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletableFuture;

@Service
public class ReminderServiceImpl implements ReminderService {

    private static final Logger logger = LoggerFactory.getLogger(ReminderServiceImpl.class);

    private final ReminderRepository reminderRepository;
    private final UserService userService;
    private final MedicineService medicineService;
    private final MedicineHistoryRepository medicineHistoryRepository;

    @Autowired
    public ReminderServiceImpl(ReminderRepository reminderRepository,
                               UserService userService,
                               MedicineService medicineService,
                               MedicineHistoryRepository medicineHistoryRepository) {
        this.reminderRepository = reminderRepository;
        this.userService = userService;
        this.medicineService = medicineService;
        this.medicineHistoryRepository = medicineHistoryRepository;
    }

    @Override
    @CacheEvict(cacheNames = "remindersByUser", allEntries = true)
    public Reminder createReminder(Long userId, Long medicineId, LocalTime reminderTime, String daysOfWeek) {
        logger.info("Создание напоминания: user={}, medicine={}, time={}", userId, medicineId, reminderTime);
        User user = userService.findById(userId);
        if (user == null) throw new RuntimeException("Пользователь не найден");
        Medicine medicine = medicineService.findById(medicineId);
        if (medicine == null) throw new RuntimeException("Лекарство не найдено");
        Reminder reminder = new Reminder(user, medicine, reminderTime);
        if (daysOfWeek != null) reminder.setDaysOfWeek(daysOfWeek);
        Reminder savedReminder = reminderRepository.save(reminder);
        logger.info("Напоминание создано: id={}", savedReminder.getId());
        return savedReminder;
    }

    @Override
    @Cacheable(cacheNames = "remindersByUser", key = "#userId")
    public List<Reminder> getUserReminders(Long userId) {
        logger.debug("Получение напоминаний для user={}", userId);
        User user = userService.findById(userId);
        if (user == null) throw new RuntimeException("Пользователь не найден");
        List<Reminder> reminders = reminderRepository.findByUser(user);
        logger.debug("Найдено {} напоминаний", reminders.size());
        return reminders;
    }

    @Override
    public Reminder findById(Long reminderId) {
        logger.debug("Поиск напоминания id={}", reminderId);
        return reminderRepository.findById(reminderId)
                .orElseThrow(() -> new RuntimeException("Напоминание не найдено"));
    }

    @Override
    @Cacheable(cacheNames = "remindersByUser", key = "#userId")
    public List<Reminder> getUserActiveReminders(Long userId) {
        logger.debug("Получение активных напоминаний для user={}", userId);
        User user = userService.findById(userId);
        if (user == null) throw new RuntimeException("Пользователь не найден");
        return reminderRepository.findByUserAndIsActiveTrue(user);
    }

    @Override
    @Cacheable(cacheNames = "remindersAll")
    public List<Reminder> getAllActiveReminders() {
        logger.debug("Получение всех активных напоминаний");
        return reminderRepository.findByIsActiveTrue();
    }

    @Override
    public List<Reminder> getDueReminders() {
        logger.debug("Поиск напоминаний для отправки");
        List<Reminder> dueReminders = new ArrayList<>();
        List<Reminder> activeReminders = reminderRepository.findAllActiveWithUserAndMedicine();
        for (Reminder reminder : activeReminders) {
            if (shouldNotifyNow(reminder)) {
                dueReminders.add(reminder);
                logger.debug("Найдено для отправки: id={}", reminder.getId());
            }
        }
        logger.debug("Всего для отправки: {}", dueReminders.size());
        return dueReminders;
    }

    @Override
    @CacheEvict(cacheNames = {"remindersByUser", "remindersAll"}, allEntries = true)
    public Reminder toggleReminder(Long reminderId, Boolean isActive) {
        logger.debug("Toggle reminder {} -> {}", reminderId, isActive);
        Reminder reminder = reminderRepository.findById(reminderId).orElse(null);
        if (reminder == null) return null;
        reminder.setActive(isActive);
        Reminder updated = reminderRepository.save(reminder);
        logger.info("Reminder {} active -> {}", updated.getId(), isActive);
        return updated;
    }

    @Override
    @CacheEvict(cacheNames = {"remindersByUser", "remindersAll"}, allEntries = true)
    public Reminder updateReminderTime(Long reminderId, LocalTime newTime) {
        logger.debug("Update reminder time {} -> {}", reminderId, newTime);
        Reminder reminder = reminderRepository.findById(reminderId).orElse(null);
        if (reminder == null) return null;
        reminder.setReminderTime(newTime);
        Reminder updated = reminderRepository.save(reminder);
        logger.info("Reminder {} time updated", updated.getId());
        return updated;
    }

    @Override
    @Transactional
    @CacheEvict(cacheNames = {"remindersByUser", "remindersAll"}, allEntries = true)
    public boolean deleteReminder(Long reminderId) {
        logger.debug("Delete reminder {}", reminderId);
        if (!reminderRepository.existsById(reminderId)) {
            logger.warn("Reminder {} not found for deletion", reminderId);
            return false;
        }
        try {
            medicineHistoryRepository.deleteByReminderId(reminderId);
            reminderRepository.deleteById(reminderId);
            logger.info("Reminder {} and related history deleted", reminderId);
            return true;
        } catch (Exception e) {
            logger.error("Error deleting reminder history: {}", e.getMessage(), e);
            throw e;
        }
    }

    @Override
    public boolean shouldNotifyNow(Reminder reminder) {
        LocalDateTime now = LocalDateTime.now();
        LocalTime rt = reminder.getReminderTime();
        boolean timeMatches = now.getHour() == rt.getHour() && now.getMinute() == rt.getMinute();
        boolean dayMatches = checkDayOfWeek(reminder, now);
        logger.debug("Checking reminder {} now={} tm={} dm={}", reminder.getId(), now, timeMatches, dayMatches);
        return timeMatches && dayMatches;
    }

    private boolean checkDayOfWeek(Reminder reminder, LocalDateTime now) {
        String daysOfWeek = reminder.getDaysOfWeek();
        if (daysOfWeek == null || daysOfWeek.equals("everyday")) return true;
        int currentDay = now.getDayOfWeek().getValue();
        return daysOfWeek.contains(String.valueOf(currentDay));
    }

    @Override
    @CacheEvict(cacheNames = {"remindersByUser", "remindersAll"}, allEntries = true)
    public Reminder updateReminder(Long reminderId, Long medicineId, LocalTime reminderTime, String daysOfWeek) {
        logger.debug("Update reminder id={}", reminderId);
        Reminder reminder = reminderRepository.findById(reminderId)
                .orElseThrow(() -> new RuntimeException("Напоминание не найдено"));
        Medicine medicine = medicineService.findById(medicineId);
        if (medicine == null) throw new RuntimeException("Лекарство не найдено");
        reminder.setMedicine(medicine);
        reminder.setReminderTime(reminderTime);
        if (daysOfWeek != null) reminder.setDaysOfWeek(daysOfWeek);
        Reminder updated = reminderRepository.save(reminder);
        logger.info("Reminder {} updated", updated.getId());
        return updated;
    }

    @Async
    public CompletableFuture<List<Reminder>> getUserRemindersAsync(Long userId) {
        return CompletableFuture.completedFuture(getUserReminders(userId));
    }
}
