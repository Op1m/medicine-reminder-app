<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover" />
    <title>üîç –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø—Ä–µ–ø–∞—Ä–∞—Ç–æ–≤</title>
    <style>
        body { font-family: monospace; padding: 16px; background: #f5f5f5; margin: 0; }
        .container { max-width: 600px; margin: 0 auto; background: white; border-radius: 24px; padding: 20px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); }
        h1 { font-size: 20px; margin-top: 0; }
        .log { background: #1e1e2f; color: #aaffaa; padding: 12px; border-radius: 12px; white-space: pre-wrap; word-break: break-word; font-size: 12px; max-height: 400px; overflow-y: auto; }
        .section { margin: 20px 0; padding: 12px; background: #f0f4f8; border-radius: 12px; }
        .label { font-weight: bold; margin-bottom: 8px; color: #0a2540; }
        .value { background: white; padding: 8px; border-radius: 8px; border: 1px solid #ddd; font-size: 13px; overflow-x: auto; }
        button { background: #2e7aff; color: white; border: none; padding: 12px 20px; border-radius: 30px; font-weight: bold; width: 100%; margin: 8px 0; cursor: pointer; }
        button.secondary { background: #6c757d; }
        .badge { background: #2e7aff; color: white; padding: 4px 10px; border-radius: 20px; font-size: 12px; display: inline-block; margin: 2px; }
    </style>
</head>
<body>
<div class="container">
    <h1>üîç –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –ø—Ä–µ–ø–∞—Ä–∞—Ç–æ–≤</h1>

    <div class="section">
        <div class="label">üë§ –¢–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å</div>
        <div class="value" id="userDisplay">‚Äî</div>
    </div>

    <div class="section">
        <div class="label">üìÖ –í—ã–±—Ä–∞–Ω–Ω—ã–π –¥–µ–Ω—å</div>
        <div class="value" id="selectedDayDisplay">‚Äî</div>
    </div>

    <div class="section">
        <div class="label">üì¶ –í—Å–µ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è (reminders)</div>
        <div class="value" id="remindersDisplay">‚Äî</div>
    </div>

    <div class="section">
        <div class="label">üìä –ò—Å—Ç–æ—Ä–∏—è –Ω–∞ –≤—ã–±—Ä–∞–Ω–Ω—ã–π –¥–µ–Ω—å</div>
        <div class="value" id="historyDisplay">‚Äî</div>
    </div>

    <div class="section">
        <div class="label">üîé –û—Ç—Ñ–∏–ª—å—Ç—Ä–æ–≤–∞–Ω–Ω—ã–µ –Ω–∞ –¥–µ–Ω—å</div>
        <div class="value" id="filteredDisplay">‚Äî</div>
    </div>

    <div class="section">
        <div class="label">üìã –ü–æ—Å–ª–µ–¥–Ω–∏–µ –¥–µ–π—Å—Ç–≤–∏—è (–ª–æ–≥)</div>
        <div class="log" id="logArea">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞...</div>
    </div>

    <button id="createTestBtn">üß™ –°–æ–∑–¥–∞—Ç—å —Ç–µ—Å—Ç–æ–≤—ã–π –ø—Ä–µ–ø–∞—Ä–∞—Ç (08:30, everyday)</button>
    <button id="refreshBtn" class="secondary">üîÑ –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
    <button id="clearBtn" class="secondary">üóëÔ∏è –û—á–∏—Å—Ç–∏—Ç—å –ª–æ–≥</button>
</div>

<script src="https://telegram.org/js/telegram-web-app.js"></script>
<script>
    (function() {
        const API_BASE = 'https://medicine-reminder-app-t3u9.onrender.com/api';
        const TOKEN_KEY = 'med_token';
        const USER_KEY = 'med_user';

        let currentUser = null;
        let authToken = localStorage.getItem(TOKEN_KEY);
        let reminders = [];
        let historyMap = new Map();
        let selectedDay = new Date();
        let logLines = [];

        // –≠–ª–µ–º–µ–Ω—Ç—ã
        const userDisplay = document.getElementById('userDisplay');
        const selectedDayDisplay = document.getElementById('selectedDayDisplay');
        const remindersDisplay = document.getElementById('remindersDisplay');
        const historyDisplay = document.getElementById('historyDisplay');
        const filteredDisplay = document.getElementById('filteredDisplay');
        const logArea = document.getElementById('logArea');
        const createTestBtn = document.getElementById('createTestBtn');
        const refreshBtn = document.getElementById('refreshBtn');
        const clearBtn = document.getElementById('clearBtn');

        function log(...args) {
            const line = args.map(a =>
                typeof a === 'object' ? JSON.stringify(a, null, 2) : String(a)
            ).join(' ');
            logLines.unshift(`üïí ${new Date().toLocaleTimeString()}: ${line}`);
            if (logLines.length > 30) logLines.pop();
            logArea.innerText = logLines.join('\n');
            console.log(...args);
        }

        async function apiFetch(endpoint, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                ...options.headers,
            };
            if (authToken) {
                headers['Authorization'] = `Bearer ${authToken}`;
            }
            const response = await fetch(API_BASE + endpoint, {
                ...options,
                headers,
            });
            if (!response.ok) {
                const error = await response.json().catch(() => ({}));
                throw new Error(error.message || `HTTP ${response.status}`);
            }
            return response.json();
        }

        async function loginWithTelegram() {
            const tg = window.Telegram?.WebApp;
            if (!tg || !tg.initData) {
                currentUser = { id: 1, firstName: '–¢–µ—Å—Ç', lastName: '', username: 'test', photoUrl: null };
                authToken = 'fake-token';
                localStorage.setItem(TOKEN_KEY, authToken);
                localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
                updateUserInfo();
                await loadReminders();
                return;
            }

            try {
                const data = await apiFetch('/auth/telegram', {
                    method: 'POST',
                    body: JSON.stringify({ initData: tg.initData }),
                });
                authToken = data.token;
                currentUser = data.user;
                log('‚úÖ –í—Ö–æ–¥ —á–µ—Ä–µ–∑ Telegram —É—Å–ø–µ—à–µ–Ω');
                log('–î–∞–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è:', currentUser);
                localStorage.setItem(TOKEN_KEY, authToken);
                localStorage.setItem(USER_KEY, JSON.stringify(currentUser));
                await loadReminders();
            } catch (err) {
                log('‚ùå –û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', err.message);
                currentUser = { id: 1, firstName: '–û—à–∏–±–∫–∞', lastName: '', username: 'error', photoUrl: null };
            }
            updateUserInfo();
        }

        async function loadReminders() {
            if (!currentUser) return;
            try {
                log('–ó–∞–≥—Ä—É–∑–∫–∞ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π –¥–ª—è userId:', currentUser.id);
                const data = await apiFetch(`/reminders/user/${currentUser.id}`);
                reminders = data;
                log('üì¶ –ü–æ–ª—É—á–µ–Ω–æ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π:', reminders.length);
                log('–°–ø–∏—Å–æ–∫ ID:', reminders.map(r => r.id));
                await loadHistoryForDate(selectedDay);
            } catch (err) {
                log('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏–π:', err.message);
            }
            updateDisplay();
        }

        async function loadHistoryForDate(date) {
            if (!currentUser) return;
            const start = new Date(date);
            start.setHours(0,0,0,0);
            const end = new Date(date);
            end.setHours(23,59,59,999);

            const startISO = start.toISOString();
            const endISO = end.toISOString();

            try {
                log('–ó–∞–≥—Ä—É–∑–∫–∞ –∏—Å—Ç–æ—Ä–∏–∏ –Ω–∞', date.toDateString());
                const history = await apiFetch(`/medicine-history/user/${currentUser.id}/period?start=${encodeURIComponent(startISO)}&end=${encodeURIComponent(endISO)}`);
                const dateKey = date.toISOString().split('T')[0];
                historyMap.set(dateKey, history);
                log('üìä –ü–æ–ª—É—á–µ–Ω–æ –∑–∞–ø–∏—Å–µ–π –∏—Å—Ç–æ—Ä–∏–∏:', history.length);
            } catch (err) {
                log('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏—Å—Ç–æ—Ä–∏–∏:', err.message);
            }
        }

        function remindersForDate(date) {
            const dayOfWeek = date.getDay() === 0 ? 7 : date.getDay();
            log('üîé –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –¥–Ω—é:', date.toDateString(), '–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏:', dayOfWeek);
            const filtered = reminders.filter(r => {
                const days = r.daysOfWeek;
                log(`  ‚è∫ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ ${r.id} (${r.medicine.name}), days: "${days}"`);
                if (days === 'everyday') return true;
                const daysArray = days.split(',').map(d => parseInt(d));
                const matches = daysArray.includes(dayOfWeek);
                log(`    –¥–Ω–∏: ${daysArray}, —Å–æ–≤–ø–∞–¥–µ–Ω–∏–µ: ${matches}`);
                return matches;
            });
            log('‚úÖ –ü–æ—Å–ª–µ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –æ—Å—Ç–∞–ª–æ—Å—å:', filtered.length);
            return filtered;
        }

        function getStatusForReminderOnDate(reminder, date) {
            const dateKey = date.toISOString().split('T')[0];
            const history = historyMap.get(dateKey) || [];
            const entry = history.find(h => h.reminder.id === reminder.id);
            return entry ? entry.status.toLowerCase() : 'pending';
        }

        function updateDisplay() {
            userDisplay.innerText = JSON.stringify(currentUser, null, 2) || '‚Äî';
            selectedDayDisplay.innerText = selectedDay.toDateString() + ' (–¥–µ–Ω—å –Ω–µ–¥–µ–ª–∏: ' + (selectedDay.getDay() === 0 ? 7 : selectedDay.getDay()) + ')';
            remindersDisplay.innerText = reminders.length ? JSON.stringify(reminders.map(r => ({
                id: r.id,
                name: r.medicine.name,
                time: r.reminderTime,
                days: r.daysOfWeek,
                medicineId: r.medicine.id
            })), null, 2) : '‚Äî';

            const dateKey = selectedDay.toISOString().split('T')[0];
            const history = historyMap.get(dateKey) || [];
            historyDisplay.innerText = history.length ? JSON.stringify(history.map(h => ({
                id: h.id,
                reminderId: h.reminder.id,
                status: h.status,
                time: h.scheduledTime
            })), null, 2) : '‚Äî';

            const filtered = remindersForDate(selectedDay);
            filteredDisplay.innerText = filtered.length ? JSON.stringify(filtered.map(r => ({
                id: r.id,
                name: r.medicine.name,
                status: getStatusForReminderOnDate(r, selectedDay)
            })), null, 2) : '‚Äî';
        }

        async function createTestReminder() {
            if (!currentUser) return;
            try {
                log('üß™ –°–æ–∑–¥–∞–Ω–∏–µ —Ç–µ—Å—Ç–æ–≤–æ–≥–æ –ª–µ–∫–∞—Ä—Å—Ç–≤–∞ –∏ –Ω–∞–ø–æ–º–∏–Ω–∞–Ω–∏—è...');
                const medicine = await apiFetch('/medicines', {
                    method: 'POST',
                    body: JSON.stringify({
                        name: '–¢–µ—Å—Ç–æ–≤—ã–π –ø—Ä–µ–ø–∞—Ä–∞—Ç ' + new Date().toLocaleTimeString(),
                        dosage: '1 —Ç–∞–±.',
                        description: '',
                        instructions: '–≤–æ –≤—Ä–µ–º—è –µ–¥—ã',
                    }),
                });
                log('‚úÖ –õ–µ–∫–∞—Ä—Å—Ç–≤–æ —Å–æ–∑–¥–∞–Ω–æ, ID:', medicine.id);

                const reminder = await apiFetch('/reminders', {
                    method: 'POST',
                    body: JSON.stringify({
                        userId: currentUser.id,
                        medicineId: medicine.id,
                        reminderTime: '08:30',
                        daysOfWeek: 'everyday',
                    }),
                });
                log('‚úÖ –ù–∞–ø–æ–º–∏–Ω–∞–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ, ID:', reminder.id);
                log('–ü–æ–ª–Ω—ã–π –æ—Ç–≤–µ—Ç:', reminder);

                reminders.push(reminder);
                log('üì¶ –ú–∞—Å—Å–∏–≤ reminders –ø–æ—Å–ª–µ push —Å–æ–¥–µ—Ä–∂–∏—Ç ID:', reminders.map(r => r.id));

                await loadHistoryForDate(selectedDay);
                updateDisplay();
                log('üîÑ –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ');
            } catch (err) {
                log('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è:', err.message);
            }
        }

        createTestBtn.addEventListener('click', createTestReminder);
        refreshBtn.addEventListener('click', async () => {
            log('üîÑ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ');
            await loadReminders();
            updateDisplay();
        });
        clearBtn.addEventListener('click', () => {
            logLines = [];
            logArea.innerText = '';
        });

        (async function init() {
            log('üöÄ –ó–∞–ø—É—Å–∫ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏');
            const savedUser = localStorage.getItem(USER_KEY);
            if (savedUser) {
                try {
                    currentUser = JSON.parse(savedUser);
                    authToken = localStorage.getItem(TOKEN_KEY);
                    log('üë§ –ó–∞–≥—Ä—É–∂–µ–Ω –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∏–∑ localStorage');
                    await loadReminders();
                } catch (e) {
                    log('‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ localStorage');
                }
            }
            if (!currentUser) {
                await loginWithTelegram();
            }
            updateDisplay();
        })();
    })();
</script>
</body>
</html>